<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4: http://docutils.sourceforge.net/" />
<title>How to define a snippet ?</title>
<meta name="author" content="pluskid" />
<meta name="date" content="2008-03-20" />
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2005-12-18 01:56:14 +0100 (Sun, 18 Dec 2005) $
:Revision: $Revision: 4224 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="how-to-define-a-snippet">
<h1 class="title">How to define a snippet ?</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>pluskid</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first last reference" href="mailto:pluskid&#64;gmail.com">pluskid&#64;gmail.com</a></td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2008-03-20</td></tr>
</tbody>
</table>
<div class="contents topic">
<p class="topic-title first"><a id="contents" name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#define-snippets-in-files" id="id9" name="id9">Define snippets in files</a><ul>
<li><a class="reference" href="#directory-hierarchy" id="id10" name="id10">Directory hierarchy</a></li>
<li><a class="reference" href="#file-content" id="id11" name="id11">File content</a></li>
<li><a class="reference" href="#define-snippets-using-elisp-code" id="id12" name="id12">Define snippets using elisp code</a><ul>
<li><a class="reference" href="#yas-define-snippets" id="id13" name="id13">yas/define-snippets</a></li>
<li><a class="reference" href="#yas-compile-bundle" id="id14" name="id14">yas/compile-bundle</a></li>
<li><a class="reference" href="#yas-define" id="id15" name="id15">yas/define</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#the-strategy-to-select-a-snippet" id="id16" name="id16">The strategy to select a snippet</a><ul>
<li><a class="reference" href="#finding-the-key" id="id17" name="id17">Finding the key</a></li>
<li><a class="reference" href="#the-condition-system" id="id18" name="id18">The condition system</a></li>
<li><a class="reference" href="#multiple-snippet-with-the-same-key" id="id19" name="id19">Multiple snippet with the same key</a><ul>
<li><a class="reference" href="#popup-menu" id="id20" name="id20">Popup Menu</a></li>
<li><a class="reference" href="#just-select-the-first-one" id="id21" name="id21">Just select the first one</a></li>
<li><a class="reference" href="#use-a-dropdown-menu-el" id="id22" name="id22">Use a dropdown-menu.el</a></li>
</ul>
</li>
<li><a class="reference" href="#the-trigger-key" id="id23" name="id23">The Trigger Key</a><ul>
<li><a class="reference" href="#the-minor-mode" id="id24" name="id24">The Minor Mode</a></li>
<li><a class="reference" href="#the-fallback" id="id25" name="id25">The Fallback</a></li>
</ul>
</li>
<li><a class="reference" href="#other-way-to-select-a-snippet" id="id26" name="id26">Other way to select a snippet</a><ul>
<li><a class="reference" href="#the-menu" id="id27" name="id27">The Menu</a></li>
<li><a class="reference" href="#expanding-from-elisp-code" id="id28" name="id28">Expanding From Elisp Code</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#the-syntax-of-the-template" id="id29" name="id29">The Syntax of the Template</a><ul>
<li><a class="reference" href="#plain-text" id="id30" name="id30">Plain Text</a></li>
<li><a class="reference" href="#embedded-elisp-code" id="id31" name="id31">Embedded elisp code</a></li>
<li><a class="reference" href="#tab-stops" id="id32" name="id32">Tab Stops</a></li>
<li><a class="reference" href="#placeholders" id="id33" name="id33">Placeholders</a></li>
<li><a class="reference" href="#id4" id="id34" name="id34">Mirrors</a></li>
<li><a class="reference" href="#id5" id="id35" name="id35">Transformations</a></li>
</ul>
</li>
</ul>
</div>
<p>The most convenient way to define snippets for YASnippet is to put
them in a directory arranged by the mode and use
<tt class="docutils literal"><span class="pre">yas/load-directory</span></tt> to load them.</p>
<p>However, this might slow down the Emacs startup speed if you have many
snippets. You can use <tt class="docutils literal"><span class="pre">yas/define-snippets</span></tt> to define a bunch of
snippets for a perticular mode. But this is hard to maintain! So,
there's a better way: define your snippets in directory and use
<tt class="docutils literal"><span class="pre">yas/compile-bundle</span></tt> to compile it into a bundle file when you
modified your snippets.</p>
<p>The release bundle of YASnippet is produced by
<tt class="docutils literal"><span class="pre">yas/compile-bundle</span></tt>. The bundle use <tt class="docutils literal"><span class="pre">yas/define-snippets</span></tt> to
define snippets. This avoid the IO and parsing overhead when loading
snippets.</p>
<p>Finally, you can use <tt class="docutils literal"><span class="pre">yas/define</span></tt> to define a single snippet at your
convenience. I ofthen use this to do some testing.</p>
<div class="section">
<h1><a class="toc-backref" href="#id9" id="define-snippets-in-files" name="define-snippets-in-files">Define snippets in files</a></h1>
<div class="section">
<h2><a class="toc-backref" href="#id10" id="directory-hierarchy" name="directory-hierarchy">Directory hierarchy</a></h2>
<p>Here's the directory hierarchy of the <tt class="docutils literal"><span class="pre">snippets</span></tt> directory comes
with YASnippet:</p>
<div class="highlight"><pre>snippets
`-- text-mode/
    |-- cc-mode/
    |   |-- c++-mode/
    |   |   |-- beginend
    |   |   |-- class
    |   |   `-- using
    |   |-- c-mode/
    |   |   `-- fopen
    |   |-- do
    |   |-- for
    |   |-- if
    |   |-- inc
    |   |-- inc.1
    |   |-- main
    |   |-- once
    |   `-- struct
    |-- css-mode/
    |   |-- background
    |   |-- background.1
    |   `-- border
    |-- email
    |-- html-mode/
    |   |-- div
    |   |-- doctype
    |   |-- doctype.xhml1
    |   |-- doctype.xhtml1_1
    |   |-- doctype.xhtml1_strict
    |   `-- doctype.xhtml1_transitional
    |-- objc-mode/
    |   `-- prop
    |-- perl-mode/
    |   |-- cperl-mode/
    |   |-- eval
    |   |-- for
    |   |-- fore
    |   |-- if
    |   |-- ife
    |   |-- ifee
    |   |-- sub
    |   |-- unless
    |   |-- while
    |   |-- xfore
    |   |-- xif
    |   |-- xunless
    |   `-- xwhile
    |-- python-mode/
    |   |-- __
    |   |-- class
    |   |-- def
    |   |-- for
    |   |-- ifmain
    |   `-- while
    |-- rst-mode/
    |   |-- chapter
    |   |-- section
    |   `-- title
    |-- ruby-mode/
    |   |-- #
    |   |-- =b
    |   |-- Comp
    |   |-- all
    |   |-- am
    |   |-- any
    |   |-- app
    |   |-- bm
    |   |-- case
    |   |-- cla
    |   |-- classify
    |   |-- cls
    |   |-- collect
    |   |-- dee
    |   |-- deli
    |   |-- det
    |   |-- ea
    |   |-- eac
    |   |-- eai
    |   |-- eav
    |   |-- eawi
    |   |-- forin
    |   |-- if
    |   |-- ife
    |   |-- inject
    |   |-- mm
    |   |-- r
    |   |-- rb
    |   |-- reject
    |   |-- req
    |   |-- rreq
    |   |-- rw
    |   |-- select
    |   |-- w
    |   |-- y
    |   `-- zip
    `-- time
</pre></div>
<p>Snippet definitions are put in plain text files. They are arranged by
subdirectories. For example, snippets for <tt class="docutils literal"><span class="pre">c-mode</span></tt> are put in the
<tt class="docutils literal"><span class="pre">c-mode</span></tt> directory.</p>
<p>The parent directory acts as the <em>parent mode</em>. This is the way of
YASnippet to share snippet definitions among different modes. As you
can see above, <tt class="docutils literal"><span class="pre">c-mode</span></tt> and <tt class="docutils literal"><span class="pre">c++-mode</span></tt> share the same parents
<tt class="docutils literal"><span class="pre">cc-mode</span></tt>, while all modes are derived from <tt class="docutils literal"><span class="pre">text-mode</span></tt>. This can
be also used to as an <em>alias</em> -- <tt class="docutils literal"><span class="pre">cperl-mode</span></tt> is an empty directory
whose parent is <tt class="docutils literal"><span class="pre">perl-mode</span></tt>.</p>
<p>File names act as the snippet trigger key. Note files starting with a
dot (<tt class="docutils literal"><span class="pre">.</span></tt>) are ignored.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id11" id="file-content" name="file-content">File content</a></h2>
<p>A file defining a snippet may just contain the template for the
snippet. Optionally it can also contains some meta data for the
snippet as well as comments.</p>
<p>Generally speaking, if the file contains a line of <tt class="docutils literal"><span class="pre">#</span> <span class="pre">--</span></tt>, then all
contents above that line are considered as meta data and comments;
below are template. Or else the whole file content is considered as
the template.</p>
<p>Here's a typical example:</p>
<div class="highlight"><pre>#contributor : pluskid &lt;pluskid@gmail.com&gt;
#name : __...__
# --
__${init}__
</pre></div>
<p>Meta data are specified in the syntax of</p>
<div class="highlight"><pre>#data-name : data value
</pre></div>
<p>Any other text above <tt class="docutils literal"><span class="pre">#</span> <span class="pre">--</span></tt> is considered as comment and
ignored. Here's a list of currently supported meta data:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt>: The name of the snippet. This is a one-line description of
the snippet. It will be displayed in the menu. So it's a good idea
to select a descriptive name fo a snippet -- especially
distinguishable among similar snippets.</li>
<li><tt class="docutils literal"><span class="pre">contributor</span></tt>: The contributor of the snippet.</li>
<li><tt class="docutils literal"><span class="pre">condition</span></tt>: The condition of the snippet. This is a piece of
elisp code. If a snippet has a condition, then it will only be
expanded when the condition code evaluate to some non-nil value.</li>
</ul>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id12" id="define-snippets-using-elisp-code" name="define-snippets-using-elisp-code">Define snippets using elisp code</a></h2>
<p>As I mentioned above, you can define snippets directly by writing
elisp code.</p>
<div class="section">
<h3><a class="toc-backref" href="#id13" id="yas-define-snippets" name="yas-define-snippets">yas/define-snippets</a></h3>
<p>The basic syntax of <tt class="docutils literal"><span class="pre">yas/define-snippets</span></tt> is</p>
<div class="highlight"><pre>(<span style="color: #19177C">yas/define-snippets</span> <span style="color: #19177C">MODE</span> <span style="color: #19177C">SNIPPETS</span> <span style="color: #008000; font-weight: bold">&amp;optional</span> <span style="color: #19177C">PARENT</span>)
</pre></div>
<p>The parameters are self-descriptive. If you specify a <tt class="docutils literal"><span class="pre">PARENT</span></tt>, then
the snippets of the parents may be shared by <tt class="docutils literal"><span class="pre">MODE</span></tt>. Note if you use
this function several times, the later specified <tt class="docutils literal"><span class="pre">PARENT</span></tt> will
overwrite the original one. However, not specifying a <tt class="docutils literal"><span class="pre">PARENT</span></tt> won't
erase the original parent.</p>
<p>The <tt class="docutils literal"><span class="pre">SNIPPETS</span></tt> parameter is a list of snippet definitions. Each
element should have the following form:</p>
<div class="highlight"><pre>(<span style="color: #19177C">KEY</span> <span style="color: #19177C">TEMPLATE</span> <span style="color: #19177C">NAME</span> <span style="color: #19177C">CONDITION</span>)
</pre></div>
<p>The <tt class="docutils literal"><span class="pre">NAME</span></tt> and <tt class="docutils literal"><span class="pre">CONDITION</span></tt> can be omitted if you don't want to
provide one. Here's an example:</p>
<div class="highlight"><pre>(<span style="color: #19177C">yas/define-snippets</span> <span style="color: #19177C">&#39;c++-mode</span>
<span style="color: #666666">&#39;</span>(
  (<span style="color: #BA2121">&quot;using&quot;</span> <span style="color: #BA2121">&quot;using namespace ${std};</span>
<span style="color: #BA2121">$0&quot;</span> <span style="color: #BA2121">&quot;using namespace ... &quot;</span> <span style="color: #880000">nil</span>)
  (<span style="color: #BA2121">&quot;class&quot;</span> <span style="color: #BA2121">&quot;class ${1:Name}</span>
<span style="color: #BA2121">{</span>
<span style="color: #BA2121">public:</span>
<span style="color: #BA2121">    $1($2);</span>
<span style="color: #BA2121">    virtual ~$1();</span>
<span style="color: #BA2121">};&quot;</span> <span style="color: #BA2121">&quot;class ... { ... }&quot;</span> <span style="color: #880000">nil</span>)
  (<span style="color: #BA2121">&quot;beginend&quot;</span> <span style="color: #BA2121">&quot;${1:v}.begin(), $1.end&quot;</span> <span style="color: #BA2121">&quot;v.begin(), v.end()&quot;</span> <span style="color: #880000">nil</span>)
  )
<span style="color: #19177C">&#39;cc-mode</span>)
</pre></div>
<p>The example above is auto-generated code by <tt class="docutils literal"><span class="pre">yas/compile-bundle</span></tt>.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id14" id="yas-compile-bundle" name="yas-compile-bundle">yas/compile-bundle</a></h3>
<p><tt class="docutils literal"><span class="pre">yas/compile-bundle</span></tt> can be used to parse the snippets from a
directory hierarchy and translate them into the elisp form. The
translated code is faster to load. Further more, the generated bundle
is a stand-alone file not depending on <tt class="docutils literal"><span class="pre">yasnippet.el</span></tt>. The released
bundles of YASnippet are all generated this way.</p>
<p>The basic syntax of <tt class="docutils literal"><span class="pre">yas/compile-bundle</span></tt> is</p>
<div class="highlight"><pre>(<span style="color: #19177C">yas/compile-bundle</span> <span style="color: #008000; font-weight: bold">&amp;optional</span> <span style="color: #19177C">yasnippet</span> <span style="color: #19177C">yasnippet-bundle</span> <span style="color: #19177C">snippet-roots</span> <span style="color: #19177C">code</span>)
</pre></div>
<p>As you can see, all the parameters are optional. The default values
for those parameters are convenient for me to produce the default
release bundle:</p>
<div class="highlight"><pre>(<span style="color: #19177C">yas/compile-bundle</span> <span style="color: #BA2121">&quot;yasnippet.el&quot;</span>
                    <span style="color: #BA2121">&quot;./yasnippet-bundle.el&quot;</span>
                    <span style="color: #666666">&#39;</span>(<span style="color: #BA2121">&quot;snippets&quot;</span>)
                    <span style="color: #BA2121">&quot;(yas/initialize)&quot;</span>)
</pre></div>
<p>The <tt class="docutils literal"><span class="pre">snippet-roots</span></tt> can be a list of root directories. This is
useful when you have multiple snippet directories (maybe from other
users). The <tt class="docutils literal"><span class="pre">code</span></tt> parameter can be used to specify your own
customization code instead of the default <tt class="docutils literal"><span class="pre">(yas/initialize)</span></tt>. For
example, you can set <tt class="docutils literal"><span class="pre">yas/trigger-key</span></tt> to <tt class="docutils literal"><span class="pre">(kbd</span> <span class="pre">&quot;SPC&quot;)</span></tt> here if
you like.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id15" id="yas-define" name="yas-define">yas/define</a></h3>
<p>The basic syntax for <tt class="docutils literal"><span class="pre">yas/define</span></tt> is</p>
<div class="highlight"><pre>(<span style="color: #19177C">yas/define</span> <span style="color: #19177C">mode</span> <span style="color: #19177C">key</span> <span style="color: #19177C">template</span> <span style="color: #008000; font-weight: bold">&amp;optional</span> <span style="color: #19177C">name</span> <span style="color: #B00040">condition</span>)
</pre></div>
<p>This is only a syntax sugar for</p>
<div class="highlight"><pre>(<span style="color: #19177C">yas/define-snippets</span> <span style="color: #19177C">mode</span>
                     (<span style="color: #008000">list</span> (<span style="color: #008000">list</span> <span style="color: #19177C">key</span> <span style="color: #19177C">template</span> <span style="color: #19177C">name</span> <span style="color: #B00040">condition</span>)))
</pre></div>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id16" id="the-strategy-to-select-a-snippet" name="the-strategy-to-select-a-snippet">The strategy to select a snippet</a></h1>
<p>When user press the <tt class="docutils literal"><span class="pre">yas/trigger-key</span></tt>, YASnippet try to find a
proper snippet to expand. The strategy to find such a snippet is
explained here.</p>
<div class="section">
<h2><a class="toc-backref" href="#id17" id="finding-the-key" name="finding-the-key">Finding the key</a></h2>
<p>YASnippet search from current point backward trying to find the
snippet to be expanded. The default searching strategy is quite
powerful. For example, in <tt class="docutils literal"><span class="pre">c-mode</span></tt>, <tt class="docutils literal"><span class="pre">&quot;bar&quot;</span></tt>, <tt class="docutils literal"><span class="pre">&quot;foo_bar&quot;</span></tt>,
<tt class="docutils literal"><span class="pre">&quot;#foo_bar&quot;</span></tt> can all be recognized as a template key. Further more,
the searching is in that order. In other words, if <tt class="docutils literal"><span class="pre">&quot;bar&quot;</span></tt> is found
to be a key to some <em>valid</em> snippet, then <tt class="docutils literal"><span class="pre">&quot;foo_bar&quot;</span></tt> and
<tt class="docutils literal"><span class="pre">&quot;#foobar&quot;</span></tt> won't be searched.</p>
<p>However, this strategy can also be customized easily from the
<tt class="docutils literal"><span class="pre">yas/key-syntaxes</span></tt> variable. It is a list of syntax rules, the
default value is <tt class="docutils literal"><span class="pre">(&quot;w&quot;</span> <span class="pre">&quot;w_&quot;</span> <span class="pre">&quot;w_.&quot;</span> <span class="pre">&quot;^</span> <span class="pre">&quot;)</span></tt>. Which means search the
following thing until found one:</p>
<ul class="simple">
<li>a word.</li>
<li>a symbol. In lisp, <tt class="docutils literal"><span class="pre">-</span></tt> and <tt class="docutils literal"><span class="pre">?</span></tt> can all be part of a symbol.</li>
<li>a sequence of characters of either word, symbol or punctuation.</li>
<li>a sequence of characters of non-whitespace characters.</li>
</ul>
<p>But you'd better keep the default value unless you understand what
Emacs's syntax rule mean.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id18" id="the-condition-system" name="the-condition-system">The condition system</a></h2>
<p>I write forked snippet.el to make the smart-snippet.el. I call it
<em>smart</em>-snippet because a condition can be attached to a snippet. This
is really a good idea. However, writing condition for a snippet
usually needs good elisp and Emacs knowledge, so it is strange to many
user.</p>
<p>Later I write YASnippet and persuade people to use it instead of
smart-snippet.el. However, some user still love smart-snippet because
it is smart. So I make YASnippet smart. Even smarter than
smart-snippet.el. :p</p>
<p>Consider this scenario: you are an old Emacs hacker. You like the
abbrev-way and set <tt class="docutils literal"><span class="pre">yas/trigger-key</span></tt> to <tt class="docutils literal"><span class="pre">(kbd</span> <span class="pre">&quot;SPC&quot;)</span></tt>. However,
you don't want <tt class="docutils literal"><span class="pre">if</span></tt> to be expanded as a snippet when you are typing
in a comment block or a string (e.g. in <tt class="docutils literal"><span class="pre">python-mode</span></tt>).</p>
<p>It's OK, just specify the condition for <tt class="docutils literal"><span class="pre">if</span></tt> to be <tt class="docutils literal"><span class="pre">(not</span>
<span class="pre">(python-in-string/comment))</span></tt>. But how about <tt class="docutils literal"><span class="pre">while</span></tt>, <tt class="docutils literal"><span class="pre">for</span></tt>,
etc. ? Writing the same condition for all the snippets is just
boring. So YASnippet introduce a buffer local variable
<tt class="docutils literal"><span class="pre">yas/buffer-local-condition</span></tt>. You can set this variable to <tt class="docutils literal"><span class="pre">(not</span>
<span class="pre">(python-in-string/comment))</span></tt> in <tt class="docutils literal"><span class="pre">python-mode-hook</span></tt>. There's no way
to do this in smart-snippet.el!</p>
<p>Then, what if you really want some snippet even in comment? This is
also possible! But let's stop telling the story and look at the rules:</p>
<ul class="simple">
<li>If <tt class="docutils literal"><span class="pre">yas/buffer-local-condition</span></tt> evaluate to nil, snippet won't be
expanded.</li>
<li>If it evaluate to the a cons cell where the <tt class="docutils literal"><span class="pre">car</span></tt> is the symbol
<tt class="docutils literal"><span class="pre">require-snippet-condition</span></tt> and the <tt class="docutils literal"><span class="pre">cdr</span></tt> is a symbol (let's
call it <tt class="docutils literal"><span class="pre">requirement</span></tt>):<ul>
<li>If the snippet has no condition, then it won't be expanded.</li>
<li>If the snippet has a condition but evaluate to nil or error
occured during evaluation, it won't be expanded.</li>
<li>If the snippet has a condition that evaluate to non-nil (let's
call it <tt class="docutils literal"><span class="pre">result</span></tt>):<ul>
<li>If <tt class="docutils literal"><span class="pre">requirement</span></tt> is <tt class="docutils literal"><span class="pre">t</span></tt>, the snippet is ready to be
expanded.</li>
<li>If <tt class="docutils literal"><span class="pre">requirement</span></tt> is <tt class="docutils literal"><span class="pre">eq</span></tt> to <tt class="docutils literal"><span class="pre">result</span></tt>, the snippet is ready
to be expanded.</li>
<li>Otherwise the snippet won't be expanded.</li>
</ul>
</li>
</ul>
</li>
<li>If it evaluate to other non-nil value:<ul>
<li>If the snippet has no condition, or has a condition that evaluate
to non-nil, it is ready to be expanded.</li>
<li>Otherwise, it won't be expanded.</li>
</ul>
</li>
</ul>
<p>So set <tt class="docutils literal"><span class="pre">yas/buffer-local-condition</span></tt> like this</p>
<div class="highlight"><pre>(<span style="color: #19177C">add-hook</span> <span style="color: #19177C">&#39;python-mode-hook</span>
          <span style="color: #666666">&#39;</span>(<span style="color: #008000; font-weight: bold">lambda</span> ()
             (<span style="color: #008000; font-weight: bold">setq</span> <span style="color: #19177C">yas/buffer-local-condition</span>
                   <span style="color: #666666">&#39;</span>(<span style="color: #008000; font-weight: bold">if</span> (<span style="color: #19177C">python-in-string/comment</span>)
                        <span style="color: #666666">&#39;</span>(<span style="color: #19177C">require-snippet-condition</span> <span style="color: #666666">.</span> <span style="color: #19177C">force-in-comment</span>)
                      <span style="color: #880000">t</span>))))
</pre></div>
<p>And specify the condition for a snippet that you're going to expand in
comment to be evaluated to the symbol <tt class="docutils literal"><span class="pre">force-in-comment</span></tt>. Then it
can be expanded as you expected, while other snippets like <tt class="docutils literal"><span class="pre">if</span></tt>
still can't expanded in comment.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id19" id="multiple-snippet-with-the-same-key" name="multiple-snippet-with-the-same-key">Multiple snippet with the same key</a></h2>
<p>There can be multiple snippet bind to the same key. If you define a
snippet with a key that is already used, you'll overwrite the original
snippet definition. However, you can add a different <em>postfix</em> to the
key.</p>
<p>In general, the <em>extension</em> (consider a file name) is <em>ignored</em> when
defining a snippet. So <tt class="docutils literal"><span class="pre">def</span></tt>, <tt class="docutils literal"><span class="pre">def.1</span></tt> and <tt class="docutils literal"><span class="pre">def.mine</span></tt> will all be
valid candidates when the key is <tt class="docutils literal"><span class="pre">def</span></tt>.</p>
<p>When there are multiple candidates, YASnippet will let you select
one. The UI for selecting multiple candidate can be
customized. There're two variable related:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">yas/window-system-popup-function</span></tt>: the function used when you
have a window system.</li>
<li><tt class="docutils literal"><span class="pre">yas/text-popup-function</span></tt>: the function used when you don't have a
window system, i.e. when you are working in a terminal.</li>
</ul>
<blockquote>
Currently there're three solution come with YASnippet.</blockquote>
<div class="section">
<h3><a class="toc-backref" href="#id20" id="popup-menu" name="popup-menu">Popup Menu</a></h3>
<p>The function <tt class="docutils literal"><span class="pre">yas/x-popup-menu-for-template</span></tt> can be used to show a
popup menu for you to select. This menu will be part of you native
window system widget, which means:</p>
<ul class="simple">
<li>It usually looks beautiful. E.g. when you compile Emacs with gtk
support, this menu will be rendered with your gtk theme.</li>
<li>Emacs have little control over it. E.g. you can't use <tt class="docutils literal"><span class="pre">C-n</span></tt>,
<tt class="docutils literal"><span class="pre">C-p</span></tt> to navigate.</li>
<li>This function can't be used when in a terminal.</li>
</ul>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id21" id="just-select-the-first-one" name="just-select-the-first-one">Just select the first one</a></h3>
<p>This one is originally used in terminal mode. It doesn't let you to
choose anything, it just select the first one on behalf of you. So I
bet you never want to use this. :p</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id22" id="use-a-dropdown-menu-el" name="use-a-dropdown-menu-el">Use a dropdown-menu.el</a></h3>
<p>Originally, only the above two function is available in
YASnippet. They are difficult to use -- especially in a
terminal. Until later Jaeyoun Chung show me his
<tt class="docutils literal"><span class="pre">dropdown-menu.el</span></tt>, I say wow! It's wonderful!</p>
<ul class="simple">
<li>It works in both window system and terminal.</li>
<li>It is customizable, you can use <tt class="docutils literal"><span class="pre">C-n</span></tt>, <tt class="docutils literal"><span class="pre">C-p</span></tt> to navigate, <tt class="docutils literal"><span class="pre">q</span></tt>
to quite and even press <tt class="docutils literal"><span class="pre">6</span></tt> as a shortcut to select the 6th
candidate.</li>
</ul>
<p>So I added <tt class="docutils literal"><span class="pre">yas/dropdown-list-popup-for-template</span></tt> to support
<tt class="docutils literal"><span class="pre">dropdown-list.el</span></tt>. And upload <tt class="docutils literal"><span class="pre">dropdown-list.el</span></tt> to YASnippet
hompage for an optional download (since Jaeyoun didn't provide a URL).</p>
<p>Then finally, in 0.4.0, I included a copy of the content of
<tt class="docutils literal"><span class="pre">dropdown-list.el</span></tt> <a class="footnote-reference" href="#id6" id="id1" name="id1">[1]</a> in <tt class="docutils literal"><span class="pre">yasnippet.el</span></tt> and made it the default
way for selecting multiple candidates.</p>
<p>However, the original functions are still there, you can still use this</p>
<div class="highlight"><pre>(<span style="color: #008000; font-weight: bold">setq</span> <span style="color: #19177C">yas/window-system-popup-function</span>
      <span style="color: #19177C">&#39;yas/x-popup-menu-for-template</span>)
</pre></div>
<p>if you prefer a <em>modern</em> UI. :)</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id23" id="the-trigger-key" name="the-trigger-key">The Trigger Key</a></h2>
<p>YASnippet is implemented as a minor-mode (<tt class="docutils literal"><span class="pre">yas/minor-mode</span></tt>). The
trigger key <tt class="docutils literal"><span class="pre">yas/trigger-key</span></tt> is defined in <tt class="docutils literal"><span class="pre">yas/minor-mode-map</span></tt>
to call <tt class="docutils literal"><span class="pre">yas/expand</span></tt> to try to expand a snippet.</p>
<div class="section">
<h3><a class="toc-backref" href="#id24" id="the-minor-mode" name="the-minor-mode">The Minor Mode</a></h3>
<p>When <tt class="docutils literal"><span class="pre">yas/minor-mode</span></tt> is enabled, the trigger key will take
effect. The default key is <tt class="docutils literal"><span class="pre">(kbd</span> <span class="pre">&quot;TAB&quot;)</span></tt>, however, you can freely
set it to some other key. By default, YASnippet add a hook to
<tt class="docutils literal"><span class="pre">after-change-major-mode-hook</span></tt> to enable <tt class="docutils literal"><span class="pre">yas/minor-mode</span></tt> <a class="footnote-reference" href="#id7" id="id2" name="id2">[2]</a> in
every buffer. This works fine for most modes, however, some mode
doesn't follow the Emacs convention and doens't call this hook. You
can either explicitly hook for those mode or just add it to
<tt class="docutils literal"><span class="pre">yas/extra-mode-hooks</span></tt> to let YASnippet do it for you:</p>
<div class="highlight"><pre>(<span style="color: #008000">require</span> <span style="color: #19177C">&#39;yasnippet</span>)
(<span style="color: #19177C">add-to-list</span> <span style="color: #19177C">&#39;yas/extra-mode-hooks</span>
             <span style="color: #19177C">&#39;ruby-mode-hook</span>)
(<span style="color: #19177C">yas/initialize</span>)
</pre></div>
<p>Note that <strong>should</strong> be put after <tt class="docutils literal"><span class="pre">(require</span> <span class="pre">'yasnippet)</span></tt> and before
<tt class="docutils literal"><span class="pre">(yas/initialize)</span></tt>. Further more, you may report it to me, I'll add
that to the default value.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id25" id="the-fallback" name="the-fallback">The Fallback</a></h3>
<p>If <tt class="docutils literal"><span class="pre">yas/expand</span></tt> failed to find any suitable snippet to expand, it
will disable the minor mode temporarily and find if there's any other
command bind the <tt class="docutils literal"><span class="pre">yas/trigger-key</span></tt>. If found, the command will be
called. Usually this works very well -- when there's a snippet, expand
it, otherwise, call whatever command originally bind to the trigger
key.</p>
</div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id26" id="other-way-to-select-a-snippet" name="other-way-to-select-a-snippet">Other way to select a snippet</a></h2>
<p>When you use the trigger key (so <tt class="docutils literal"><span class="pre">yas/expand</span></tt>) to expand a snippet,
the key for the snippet is deleted before the template for the snippet
is inserted.</p>
<p>However, there're other ways to insert a snippet.</p>
<div class="section">
<h3><a class="toc-backref" href="#id27" id="the-menu" name="the-menu">The Menu</a></h3>
<p>YASnippet will setup a menu just after the <em>Buffers</em> Menu in the
menubar. The snippets for all <em>real</em> modes are listed there under the
menu. You can select a snippet from the menu to expand it. Since you
select manually from the menu, you can expand any snippet. For
example, you can expand a snippet defined for <tt class="docutils literal"><span class="pre">python-mode</span></tt> in a
<tt class="docutils literal"><span class="pre">c-mode</span></tt> buffer by selecting it from the menu:</p>
<ul class="simple">
<li>Condition system is ignored since you select to expand it
explicitly.</li>
<li>There will be no muliple candidates since they are listed in the
menu as different items.</li>
</ul>
<p>This can be convenient sometimes. However, if you don't like the
menubar of Emacs and never use it. You can tell YASnippet don't boring
to build a menu by setting <tt class="docutils literal"><span class="pre">yas/use-menu</span></tt> to nil.</p>
<p>Another thing to note is that only <em>real</em> modes are listed under the
menu. As you know, common snippets can be shared by making up a
<em>virtual</em> parent mode. It's too bad if the menu is floored by those
<em>virtual</em> modes. So YASnippet only show menus for those <em>real</em>
modes. But the snippets fo the <em>virtual</em> modes can still be accessed
through the <tt class="docutils literal"><span class="pre">parent</span></tt> submenu of some <em>real</em> mode.</p>
<p>YASnippet use a simple way to check whether a mode is <em>real</em> or
<em>virtual</em>: <tt class="docutils literal"><span class="pre">(fboundp</span> <span class="pre">mode)</span></tt>. For example, the symbol <tt class="docutils literal"><span class="pre">c-mode</span></tt> is
bound to a function while <tt class="docutils literal"><span class="pre">cc-mode</span></tt> is not. But this is not enough,
some modes aren't part of Emacs, and maybe when initializing
YASnippet, those modes haven't been initialized. So YASnippet also
maintain a list of known modes (<tt class="docutils literal"><span class="pre">yas/known-modes</span></tt>). You can add item
to that list if you need.</p>
</div>
<div class="section">
<h3><a class="toc-backref" href="#id28" id="expanding-from-elisp-code" name="expanding-from-elisp-code">Expanding From Elisp Code</a></h3>
<p>Sometimes you might want to expand a snippet directly by calling a
functin from elisp code. You should call <tt class="docutils literal"><span class="pre">yas/expand-snippet</span></tt>
instead of <tt class="docutils literal"><span class="pre">yas/expand</span></tt> in this case.</p>
<p>As with expanding from the menubar, condition system and multiple
candidates won't exists here. In fact, expanding from menubar has the
same effect of evaluating the follow code:</p>
<div class="highlight"><pre>(<span style="color: #19177C">yas/expand-snippet</span> (<span style="color: #19177C">point</span>) (<span style="color: #19177C">point</span>) <span style="color: #19177C">template</span>)
</pre></div>
<p>Where <tt class="docutils literal"><span class="pre">template</span></tt> is the template of a snippet. It is never required
to belong to any snippet -- you can even make up it on the fly. The
1st and 2nd parameter defines the region to be deleted after YASnippet
inserted the template. It is used by <tt class="docutils literal"><span class="pre">yas/expand</span></tt> to indicate the
region of the key. There's usually no need to delete any region when
we are expanding a snippet from elisp code, so passing two <tt class="docutils literal"><span class="pre">(point)</span></tt>
is fine. Note only <tt class="docutils literal"><span class="pre">(point)</span></tt> will be fine because the 1st parameter
also indicate where to insert and expand the <tt class="docutils literal"><span class="pre">template</span></tt>.</p>
</div>
</div>
</div>
<div class="section">
<h1><a class="toc-backref" href="#id29" id="the-syntax-of-the-template" name="the-syntax-of-the-template">The Syntax of the Template</a></h1>
<p>The syntax of the snippet template is simple but powerful, very
similar to TextMate's.</p>
<div class="section">
<h2><a class="toc-backref" href="#id30" id="plain-text" name="plain-text">Plain Text</a></h2>
<p>Arbitrary text can be included as the content of a template. They are
usually interpreted as plain text, except <tt class="docutils literal"><span class="pre">$</span></tt> and <tt class="docutils literal"><span class="pre">`</span></tt>. You need to
use <tt class="docutils literal"><span class="pre">\</span></tt> to escape them: <tt class="docutils literal"><span class="pre">\$</span></tt> and <tt class="docutils literal"><span class="pre">\`</span></tt>. The <tt class="docutils literal"><span class="pre">\</span></tt> itself may also
needed to be escaped as <tt class="docutils literal"><span class="pre">\\</span></tt> sometimes.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id31" id="embedded-elisp-code" name="embedded-elisp-code">Embedded elisp code</a></h2>
<p>Elisp code can be embedded inside the template. They are written
inside back-quotes (<tt class="docutils literal"><span class="pre">`</span></tt>):</p>
<p>They are evaluated when the snippet is being expanded. The evaluation
is done in the same buffer as the snippet being expanded. Here's an
example for <tt class="docutils literal"><span class="pre">c-mode</span></tt> to calculate the header file guard dynamically:</p>
<div class="highlight"><pre>#ifndef ${1:_`(upcase (file-name-nondirectory (file-name-sans-extension (buffer-file-name))))`_H_}
#define $1

$0

#endif /* $1 */
</pre></div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id32" id="tab-stops" name="tab-stops">Tab Stops</a></h2>
<p>Tab stops are fields that you can navigate back and forth by <tt class="docutils literal"><span class="pre">TAB</span></tt>
and <tt class="docutils literal"><span class="pre">S-TAB</span></tt> <a class="footnote-reference" href="#id8" id="id3" name="id3">[3]</a>. They are written by <tt class="docutils literal"><span class="pre">$</span></tt> followed with a
number. <tt class="docutils literal"><span class="pre">$0</span></tt> has the special meaning of the <em>exit point</em> of a
snippet. That is the last place to go when you've traveled all the
fields. Here's a typical example:</p>
<div class="highlight"><pre>&lt;div$1&gt;
    $0
&lt;/div&gt;
</pre></div>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id33" id="placeholders" name="placeholders">Placeholders</a></h2>
<p>Tab stops can have default values -- a.k.a placeholders. The syntax is
like this:</p>
<div class="highlight"><pre>${N:default value}
</pre></div>
<p>They acts as the default value for a tab stop. But when you firstly
type at a tab stop, the default value will be replaced by your
typing. The number can be omitted if you don't want to create
<a class="reference" href="#mirrors">mirrors</a> or <a class="reference" href="#transformations">transformations</a> for this field.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id34" id="id4" name="id4"><span id="mirrors"></span>Mirrors</a></h2>
<p>We refer the tab stops with placeholders as a <em>field</em>. A field can have
mirrors. Its mirrors will get updated when you change the text of a
field. Here's an example:</p>
<div class="highlight"><pre>\begin{${1:enumerate}}
    $0
\end{$1}
</pre></div>
<p>When you type <tt class="docutils literal"><span class="pre">&quot;document&quot;</span></tt> at <tt class="docutils literal"><span class="pre">${1:enumerate}</span></tt>, the word
<tt class="docutils literal"><span class="pre">&quot;document&quot;</span></tt> will also be inserted at <tt class="docutils literal"><span class="pre">\end{$1}</span></tt>. The best
explanation is to see the screencast(<a class="reference" href="http://www.youtube.com/watch?v=vOj7btx3ATg">YouTube</a> or <a class="reference" href="http://yasnippet.googlecode.com/files/yasnippet.avi">avi video</a>).</p>
<p>The tab stops with the same number to the field act as its mirrors. If
none of the tab stops has an initial value, the first one is selected
as the field and others mirrors.</p>
</div>
<div class="section">
<h2><a class="toc-backref" href="#id35" id="id5" name="id5"><span id="transformations"></span>Transformations</a></h2>
<p>If the default value of a field starts with <tt class="docutils literal"><span class="pre">$</span></tt>, then it is interpreted
as the transformation code instead of default value. A transformation
is some arbitrary elisp code that will get evaluated in an environment
when the variable text is bind to the inputted text of the
field. Here's an example for Objective-C:</p>
<div class="highlight"><pre>- (${1:id})${2:foo}
{
    return $2;
}

- (void)set${2:$(capitalize text)}:($1)aValue
{
    [$2 autorelease];
    $2 = [aValue retain];
}
$0
</pre></div>
<p>Look at <tt class="docutils literal"><span class="pre">${2:$(capitalize</span> <span class="pre">text)}</span></tt>, it is a transformation instead of
a placeholder. The actual placeholder is at the first line:
<tt class="docutils literal"><span class="pre">${2:foo}</span></tt>. When you type text in <tt class="docutils literal"><span class="pre">${2:foo}</span></tt>, the transformation
will be evaluated and the result will be placed there as the
transformated text. So in this example, if you type baz in the field,
the transformed text will be Baz. This example is also available in
the screencast.</p>
<p>Another example is for <tt class="docutils literal"><span class="pre">rst-mode</span></tt>. In reStructuredText, the document
title can be some text surrounded by &quot;===&quot; below and above. The &quot;===&quot;
should be at least as long as the text. So</p>
<div class="highlight"><pre>=====
Title
=====
</pre></div>
<p>is a valid title but</p>
<div class="highlight"><pre>===
Title
===
</pre></div>
<p>is not. Here's an snippet for rst title:</p>
<div class="highlight"><pre>${1:$(make-string (string-width text) ?\=)}
${1:Title}
${1:$(make-string (string-width text) ?\=)}

$0
</pre></div>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id6">[1]</a></td><td>With some minor change, mainly for fixing some trivial bugs.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2" name="id7">[2]</a></td><td>This is done when you call <tt class="docutils literal"><span class="pre">yas/initialize</span></tt>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3" name="id8">[3]</a></td><td>Of course, this can be customized.</td></tr>
</tbody>
</table>
</div>
</div>
</div>
</body>
</html>
